malloc: Implementing a dynamic memory allocation mechanism


malloc:
	the malloc function allocates size bytes and returns a pointer to the
	allocated memory. the memory is not initialized.
	if size if 0, then malloc() returns a unique pointer value that can
	later be successfully passed to free().

free:
	the free() function frees the memory space pointed to by ptr, which must
	have been returned by the previous call to malloc() or related functions.
	otherwise, or if the ptr has already been freed, undefined behavior occurs.
	if ptr is NULL, no operation is performed.

RETURN VALUE:
	the malloc, function return a pointer to the allocated memory,
	which is suitably aligned for any type that fits into the requested size or
	less. on error, these functions return NULL and set errno.
	attemting to allocate more than PTRDIFF_MAX bytes is considered an error,
	as an object that large could sause later pointer substraction to overflow.

ERRORS
	malloc can fail with the following error.
	ENONEM Out of memory, possibly the application hit the RLIMIT_AS or RLIMIT_DATA
	limit described in getrlimit, another reason could be that the number of
	mapping created by the caller process exceeded the limit specified by 
	/proc/sys/vm/max_map_count.

ATTRIBUTES
	Thread safety: MT-Safe.


heap:
the heap segment contains dynamically allocated memory,
commonly begins at the end of the BSS segement and grows to larger addresses
from there.
it is managed by malloc, calloc, realloc, and free
which may use the brk, sbrk system calls to adjust its size .
they may also be implemented using mmap/munmap to reserve/unreserve potentially
non-contigious regions of virtual memory into the process's virtual address space.
the heap segment is shared by all threads, shared libraries, and dynam loaded
modules in a process.


brk and sbrk are basic memory management system calls used in Unix and Unix-like
operating systems to control the amount of memory allocated to the heap segment
of the process.

the brk and sbrk calls dynamically change the amount of space allocated for the
heap segment of the calling process.
the change is made by resetting the program break of the process.
which determines the maximum space that can be allocated.
the program break is the address of the first location beyond the current end of
data segment.
the amount of available space increases as the break value increases.
the available space is initialized to  a value of zero.
the break value can be automatically rounded up to a size appropriate for the
memory managment architecture.



The C language guaranted that all uninitialized global variables will be
initialized to zero.

When C programs are compiled, a seperate section called .bss is used for 
uninitialized variables.
Since the value of these variables are all zeros to start with, they do not have
to be stored in "Flash". before transfering control to C code, the memory 
locations corresponding to these variables have to be initialized to zero.

GCC places global variables marked as const in a seperate section, called .rodata
the .rodata is also used for storing string constants.

Since contents of .data section will not be modified, they can be placed in "Flash"

the linker script has to modified to accomodate this.


- Process Memory Concepts:

one of the most basic resources a process has available to it is memeory.

each process has one linear virtual address space.
with addresses running from zero to some huge maximum.
it need not be contigeous, not all of these addresses actually can be used to
store data.

the virtual memory is divided into pages (4kB). Backing each page of virtual
memory is a page of real memory (called a frame) or some secondary storage, usually
disk space.
the disk space might be swap space or just some ordinary disk file.
a page of zeroes sometimes has nothing at all backing it.

the same frame of real memory or backing store can back multiple virtual pages
belonging to multiple processes 
this is normally the case for example, with virtual memory occupied by GNU C 
library code.
the same real memory frame containing the printf function backs a virtual
memory page in each of the existing processes that has a printf call in its 
program.

in order for a program to access any part of a virtual page, the page must 
at that moment be backed by "connected to" a real frame.
but because there is usually a lot more virtual memory than real memory,
the pages must move back and forth between real memory and backing 
store regularly, coming into real memory when a process needs to access them
and then retreating to backing store when not needed anymore.
this movement is called paging.

when a program attempts to access a page which is not at that moment backed by 
real memory, this is known as 'page fault'.
when a page fault occurs, the kernel suspends the process, places the page into
a real page frame (this is called 'paging in' or 'faulting in')
then resumes the process so that from the process's point of view, the page was 
in real memory all along.
in fact, to the process, all pages always seems to be in real memory.
Except for one thing; the elapsed execution time of an instrction that would normally 
be a few nanoseconds is suddenly much, much longer (because the kernel normally has to bo
I/O to complete the page-in).

within each virtual address space, a process has to keep track of what is at 
which addresses. and that process is called memory allocation.


memory-mapped I/O is another form of dynamic virtual memory allocation.
mapping memory to a file means declaring that the contents of 
certain range of a process addresses shall be identical to the contents of a 
specified file.
the system makes the virtual memory initially contain the contents fo the file.
and if you modify the memory, the system writes the same modification to the file.



dynamic memory allocation is a technique in which programs determine as they are 
running where to store some information.

you need dynamic allocation when the amount of memory you need, or how long you
continue to need it, depends on factors that are not known before the program 
runs.

the only way to get dynamically allocated memory is via a system call.
(which is generally via a GNU C library function call).
and the only way to refer to dynamically allocated space is through a pointer.
because it is less convenient and because the actual process of dynamic allocation 
requires more computation time.
programmers generally use dynamic allocation only when neither static
nor automatic allocation will serve.

- The GNU Allocator
the malloc implementation in the GNU C library is derived from the ptmalloc
(pthreads malloc), which in turn is derived from the dlmalloc (Doug Lea malloc).

this malloc may allocate memory in two different ways depending on their size 
and certain parameters that may be controlled by users 
the most common way is allocating portions of memory (called chunks) from a large
contiguous area of memory and manage these areas to optimize their use and reduce 
wastage in the form of unusable chunks.
traditionally the system heap was set up to be the one large memory area but 
GNU C library malloc implementation maintains multiple such areas to optimize 
their use in multi-threaded applications.
Each such area is internally referred to as arena.

As opposed to other versions, the malloc in the GNU C Library does not round up
chunk size to powers of 2, neither for large nor for small sizes.
Neiboring chunks can be coalesced on a free no matter what their size is.

this makes the implementation suitable for all kinds of allocation patterns 
without generally incurring high memory waste through fragmenation.

the presence of multiple arenas allows multiple threads to allocate memory 
simultaneously in seperate arenas, thus improving performance.

the other way of memory allocation is for very large blocks, 
much larger than a page.
this requests are allocated with mmap (anonymous or via /dev/zero)
this has the great advantage that these chunks are returned to the system 
immediately when they are freed.
therefor, it cannt happen that a large chunk becomes "locked" in between smaller
ones and even after calling free wastes memory.
the size threashold for mmap to be used is dynamic and gets adjusted according
to allocation patterns of the program.


the most general dynamic allocation facility is malloc
it allows you to allocate blocks of memory of any size at any time.
make them bigger or smaller at any time, and free the blocks individually
at any time (or never).

the block that malloc gives you is guaranted to be aligned so that 
it can hold any type of data.

on GNU systems, the address is always a multiple of eight on 32-bit systems,
and multiple of 16 on 64-bit.

the memory located after the end of the block is likely to be in use for something
else; perhaps a block already allocated by another call to malloc, if you attempt
to treat the block as longer than what you asked for it to be, you are liable
to distroy the data that malloc uses to keep track of it's blocks, or you may 
destroy the contents of a another block.
if you have already allocated a block and discover you want it to be bigger,
use realloc.


Portability Note:
	- in the GNU C Library, a successful malloc(0) returns a non-null pointer to
	a newly allocated size-zero block.
	other implementations may return NULL instead, POSIX and ISO C standard allow
	both behaviors.

	- in the GNU C Library, a failed malloc call sets errno, but ISO C does 
	not require this and non-POSIX implementation need not set 
	errno when failing.

	- in the GNU C Library, malloc always fails when size exceeds PTRDIFF_MAX,
	to avoid problems with programs that substract pointers or use signed indexes

Ocationally, free can actually return memory to the operating system and make
the process smaller.
usually, all it can do is allow a later call to malloc to reuse the space.
in the meantime, the space remains in your program as part of a free-list used
internally by malloc.


the free function preserve the value of errno, so that cleanup code need not worry
about saving and restoring errno around a call to free.

Replacing malloc:
the GNU C library supports replacing the built-in malloc implementation with 
a different allocator with the same interface.
For dynamically linked programs this happens through ELF symbol interposition,
either using shared object dependencies or LD_PRELOAD.
for static linking, the malloc replacement library must be linked in before
linking against libc.a (explicitly or implicitly).
!! failure to provide complete set of replacement functions 
(that is all the functions used by the application, the GNU C Library, and other
linked-in libraries) can lead to static linking failure, and at run time, to heap 
corruption and application crashes.
replacement functions should implment the behavior documented to their counterparts
in the GNU C Library,

the minimum set of functions which has to be provided by a custom malloc is given
in the table below,
	* malloc
	* free
	* calloc
	* realloc

these malloc-related functions ar erequired for the GNU C Library to work.

the malloc implementation in the GNU C Library provides addictional functionality
not used by the library itself, but which is often used by other system libraries 
and applications.

A general-purpose replacement malloc implementation should provide definitions 
of these functions too. their names are listed in the following table.

	* aligned_alloc
	* malloc_usable_size
	* memalign
	* posix_memalign
	* pvalloc
	* valloc
in Addition, very old applications may use the obsolute cfree funtion.

Further malloc-related functions such as mallopt or mallinfo2 will not have any
effect or return incorrect statistics when a replacement malloc is in use.
However failure to replace these fucntions typically does not result in crashes 
or other incorrect application behavior, but may result in static linking failure.



the address of a block returned by malloc or realloc in GNU systems is always 
a multiple of eight (or 16 on 64-bit systems)

Malloc Tunable Parameters:

you can adjust some parameters for the dynamic memory allocation with mallopt 
function.
this function is the general SVID/XPG interface, defined in malloc.h

	int mallopt(int param, int value)

	possible choices for param:
	M_MMAP_MAX:
		the maximum number of chunks to allocate with mmap, setting to 0 disables 
		all use of mmap.
		the default value of this parameter is 65536.
		
		ENV_VAR: MALLOC_MMAP_MAX_
	
	M_MMAP_THRESHOLD:
		all chunks larger than this value are allocated outside of the normal heap,
		using the mmap system call,
		this way it is guaranted that the memory for these chunks can be returned
		to the system on free
		not that requests smaller than this threashold might still be allocated via mmap
		
		if this parameter is not set, the default value is set as 128KiB and the 
		threashold is adjusted dynamically to suit the allocation patterns of
		the program. if the parameter is set, the dynamic adjustement wis disabled
		and the value is set statically to the input value.

		MALLOC_MMAP_THRESHOLD_

	M_TOP_PAD:
		this parameter determines the amount of extra memory to obtain from the
		system when an arena needs to be extended. it also specifies the number of
		bytes to retain when shrinking an arena.
		this provide the necessary hysteresis in heap size such that excessive
		amounts of system calls can be avoided.

		the default value of this parameter is 0.
		MALLOC_TOP_PAD_
	
	M_TRIM_THRESHOLD:
		this is the minimum size (in bytes) of the top-most, releasable chunk 
		that will trigger a system call in order to return the memory to the
		system
	
	M_ARENA_TEST:
		this parameter specifies the number of arenas that can be created 
		before the test on the limit to the number of arenas is conducted.

		the default value of this parameter is 2 on 32-bit systems and 8 on 64-bit systems.
	
		MALLOC_ARENA_TEST
	
	M_ARENA_MAX:
		this parameter sets the number of arenas to use regardless of the number of cores
		in the system.

		the default value of this tunable is 0, meaning that the limit 
		on the number of arenas is determined by the number of CPU cores online.

		for 32-bit systems the limit is twice the number of core online 
		and on 64-bit system, it is 8 times the number of cores online.


Statistics from Memory Allocation with malloc

you can get information about the dynamic memory allocation by calling mallinfo2
function. This function and its associated data type are decalred in malloc.h

they are an extension of the standard SVID/XPG version.

---Memory-mapped I/O:
On modern operating systems, it is possible to mmap a file to a region of memory.
when this is done the file can be accessed just like an array in the program.

this is more effiecient than read or write, as only the regions of the file that
a program actually accesses are loaded.

Accesses to not-yet loaded parts of the mmpped region handled in the same way as
swapped pages.

Since mmaped pages can be stored back to their file when physical memory is low,
it is possible to mmap files orders of magnitude larger than both the physical 
memory and swap space.
the only limit is address space

Memory mapping only works on entire pages of memory. thus, addresses for mapping
must be page-aligned, and length value will be rounded up
to determine the default size of a page the machine uses one should use:
	size_t page_size = (size_t) sysconf (_SC_PAGESIZE);

the mmap function creates a new mapping, connected to bytes (offset) to (offset + length - 1)
in the file open on filedes.
a new reference on the file specified by filedes is created, which is not removed
by closing the file.


flags:
	MAP_ANON:
		this flags tells the system to create an anonymous mapping, not connected 
		to a file. filedes and offset are ignored, and the region is initialized
		with 0.

		Anonymous maps are used as the basic primitive to extend the heap on 
		some systems.
		they are also useful to share data between multiple tasks without creating
		a file.


		on some systems using private Anonymous mmaps is more effiecient than using
		malloc for large blocks. this is not an issue with the GNU C Library,
		as the included malloc automatically uses mmap where appropriate.

